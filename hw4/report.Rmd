---
title: "30-Day Mortality Rate of Patients with Pneumonia Admitted to MICU"
author: "Ami Sheth"
output: html_document
---

## Introduction

The MIMIC-III (Medical Information Mart for Intensive Care III) is a database containing deidentified health-related data for over 40,000 patients staying in critical care units of Beth Israel Denaconess Medical Center between 2001 and 2012. The database consists of forty different tables pertaining to hospital admissions, patient demographics, patient diagnosis, prescriptions, etc. The following analysis seeks to predict the mortality rate of patients diagnosed with pneumonia who were admitted to the medical intensive care unit (MICU) thirty days after discharge. 

## Data Preparation 

The MIMIC-III data is accessed by connecting to the PostgresSQL database. A cohort of patients directly admitted into MICU is extracted from the `transfer` table which contains information about the physical location of patients throughout their hospital stay. The `d_icd_diagnoses` table labels all diagnoses according to the Dictionary of International Classification of Diseases, 9th Revision (ICD-9 Codes). From this table, all ICD-9 codes related to pneumonia are stored and matched to patients' ICD-9 codes in the `diagnoses_icd` table. The `diagnoses_icd` table stores the diagnosis of each admission. 

Pneumonia may not be listed as the principal diagnosis as explained in [the documentation for the `patients` table](https://mimic.physionet.org/mimictables/diagnoses_icd/). The `seq_num` field is a priority ranking for the diagnoses generated at the end of stay. In order to focus on patients for whom pneumonia was central to their hospitalization, recrods with pnuemonia in any of the first five diagnosis positions, according to `seq_num` is kept. Additionally, to avoid duplicate admissions, we use `group_by()` to limit the query to the first pneumonia diagnosis for each admission.

Now, the dataset containing only patients from MICU is joined with the dataset containing only pneumonia patients to obtain a cohort restricted to pneumonia patients who were direclty admitted into the MICU. 

### Code

The following steps are performed to create a cohort of patients who were directly admitted into MICU and were diagnosed with pneumonia. 

Load database libraries:
```{r}
library(DBI)
library(RPostgreSQL)
library(tidyverse)
library(lubridate)

```
 
Connect to PostgreSQL 
```{r}
# Load configuration settings
dbdriver <- 'PostgreSQL'
user  <- 'postgres'
password <- 'postgres'
dbname <- 'mimic'
schema <- 'mimiciii'

# Connect to the database using the configuration settings
con <- dbConnect(RPostgreSQL::PostgreSQL(), 
                 dbname = dbname,
                 user = user, 
                 password = password)

# Set the default schema
dbExecute(con, paste("SET search_path TO ", schema, sep=" "))
con
```

Create a (query) table of patients who were directly admitted into MICU
```{r}

tbl(con, "transfers") %>%
  select(subject_id, hadm_id, prev_careunit, curr_careunit) %>%
  filter(is.na(prev_careunit) & curr_careunit == "MICU") %>%
  select(subject_id, hadm_id) %>%
  distinct() %>%
  print() -> micu_admissions

# collect(micu_admissions)
```

Restrict to pneumonia patients; to find all possible ICD-9 codes related to pneumonia, search for string `pneumonia` in the `long_title` of table `d_icd_diagnoses`
```{r}

tbl(con, "d_icd_diagnoses") %>%
  filter(str_detect(tolower(long_title), "pneumonia")) %>%
  print() -> pneu_codes

```

`diagnoses_icd` table stores the diagnosis of each admission. We use `semi_join()` to keep the rows in `diagnoses_icd` that match the ICD-9 codes related to pneumonia:
```{r}
tbl(con, "diagnoses_icd") %>%
  semi_join(pneu_codes, by = "icd9_code") %>%
  print() -> pneu_admissions

 # collect(pneu_admissions)
```

Pneumonia may not be listed as the principal diagnosis as explained in [the documentation for the `patients` table](https://mimic.physionet.org/mimictables/diagnoses_icd/). The `seq_num` field is a priority ranking for the diagnoses generated at the end of stay. In order to focus on patients for whom pneumonia was central to their hospitalization, we will include records with pneumonia in any of the first five diagnosis positions, according to the `seq_num` field. To avoid duplicate admissions, we use `group_by()` to limit the query to the first pneumonia diagnosis for each admission.

```{r}
pneu_admissions %>%
  filter(seq_num <= 5) %>%
  group_by(subject_id, hadm_id) %>%
  filter(min_rank(seq_num) <= 1) %>%
  ungroup() %>%
  select(subject_id, hadm_id, icd9_code, seq_num) %>%
  print() -> pneu_admissions

# collect(pneu_admissions)
```

`inner_join` the table of admissions to MICU and the table of admissions that include pneumonia diagnosis
```{r}
micu_admissions %>%
  inner_join(pneu_admissions, by = c("subject_id", "hadm_id")) %>%
  print() -> cohort_admissions

# collect(cohort_admissions)
```

## Transform and augment query tables

Now we create a logical variable indicating the pneumonia is the principal diagonosis or not (according to `seq_num`).
```{r}
cohort_admissions %>%
  mutate(principal_dx = seq_num == 1) %>%
  select(-seq_num) %>%
  print() -> cohort_admissions

# collect(cohort_admissions)
```

We want to add information about the severity of patients’ ailments. The `drgcodes` table contains, for `DRG` codes from the All Payers Registry (APR), severity and mortality indicators. We pull the drug severity information and right-join it to our query table.
```{r}
tbl(con, "drgcodes") %>%
  filter(str_detect(drg_type, "APR")) %>%
  select(subject_id, hadm_id, drg_severity) %>%
  right_join(cohort_admissions, by = c("subject_id", "hadm_id")) %>%
  mutate(drg_severity = ifelse(is.na(drg_severity), 1, drg_severity)) %>%
  print() -> cohort_admissions

 # collect(cohort_admissions)
```

Pull the admission time `admittime`, discharge time `dischtime`, date of birth `dob`, and date of death `dod`. We are interested in the mortaility rate 30 days after discharge. So we only keep patients who didn't die in hospital.
```{r}
cohort_admissions %>%
  left_join(
    select(tbl(con, "admissions"),
           subject_id, hadm_id, admittime, dischtime, hospital_expire_flag
    ), by = c("subject_id", "hadm_id")
  ) %>%
  filter(hospital_expire_flag == 0) %>% # patients who did not die in hospital
  select(-hospital_expire_flag) %>%
  left_join(
    select(tbl(con, "patients"), subject_id, dob, dod),
    by = "subject_id"
  ) %>%
  print(width = Inf) -> cohort_admissions

# collect(cohort_admissions)
```

To add `age` (at admission) variable into the table. [The documentation for the patients table](https://mimic.physionet.org/mimictables/patients/) explains that patients of 90 years and older had their ages artificially inflated, so we remove these patients from the analysis.
```{r}
cohort_admissions %>%
  mutate(tt_death = DATE_PART("day", dod - dischtime)) %>%
  mutate(mortality = tt_death <= 30) %>%
  mutate(age = date_part("year", admittime) - date_part("year", dob)) %>%
  filter(age < 90) %>%
  mutate(age = age - ifelse(
    date_part("month", admittime) < date_part("month", dob) |
      (
        date_part("month", admittime) == date_part("month", dob) &
          date_part("day", admittime) < date_part("day", dob)
      ),
    1,
    0
  )) %>%
  select(-admittime, -dischtime, -dob, -dod, -tt_death) %>%
  select(subject_id, hadm_id, age, mortality, everything()) %>%
  print() -> cohort_admissions

# collect(cohort_admissions)
```
Many mortality indicators are missing, due to neither the hospital database nor the social security database having a record of these patients’ deaths. We could convert these to `FALSE` values, but it may be helpful to retain in the analytic table this information on whether deaths were recorded at all, e.g. for validation or sensitivity testing.

Finally, let's merge some demographic information (ethnicity, gender) into our study `cohort_admissions`.
```{r}
tbl(con, "admissions") %>%
  select(subject_id, ethnicity) %>%
  distinct() %>%
  print() -> cohort_subjects

# collect(cohort_subjects)
```

```{r}
tbl(con, "patients") %>%
  select(subject_id, gender) %>%
  distinct() %>%
  full_join(cohort_subjects, by = "subject_id") %>%
  print() -> cohort_subjects

# collect(cohort_subjects)
```

```{r}
cohort_subjects %>%
  semi_join(cohort_admissions, by = "subject_id") %>%
  print() -> cohort_subjects

# collect(cohort_subjects)
```
Let's resolve some diversity and inconsistency in the `ethnicity` field:
```{r}
unknown_ethnicity <- c(
  "OTHER",
  "UNABLE TO OBTAIN",
  "UNKNOWN/NOT SPECIFIED",
  "MULTI RACE ETHNICITY",
  "PATIENT DECLINED TO ANSWER",
  "UNKNOWN"
)

cohort_subjects %>%
  collect() %>%
  mutate(ethnic_group = case_when(
    str_detect(ethnicity, "^ASIAN") ~ "ASIAN",
    str_detect(ethnicity, "^BLACK") ~ "BLACK",
    str_detect(ethnicity, "^HISPANIC") ~ "HISPANIC",
    str_detect(ethnicity, "^WHITE") ~ "WHITE",
    ethnicity %in% unknown_ethnicity ~ NA_character_,
    TRUE ~ NA_character_
  )) %>%
  select(subject_id, gender, ethnic_group) %>%
  print() -> cohort_subjects
```

Some patients are coded as belonging to more than one ethnic group. To resolve these inconsistencies, we define a helper function to pick the modal value from a vector of values in R, which can be used by the `summarize()` function to choose one ethnic group for each patient.
```{r}
most <- function(x) {
  if (all(is.na(x))) return(NA_character_)
  y <- table(x, useNA = "no")
  if (length(which(y == max(y))) > 1) return(NA_character_)
  return(names(y)[which.max(y)])
}

cohort_subjects %>%
  group_by(subject_id) %>%
  summarize(ethnic_group = most(ethnic_group)) %>%
  ungroup() %>%
  mutate(ethnic_group = ifelse(is.na(ethnic_group), "UNKNOWN", ethnic_group)) %>%
  print() -> cohort_ethnic_groups
```
```{r}
cohort_subjects %>%
  select(subject_id, gender) %>%
  left_join(cohort_ethnic_groups, by = "subject_id") %>%
  print() -> cohort_subjects
```
Now we add the demographic information `gender` and `ethnicity` into our `cohort_admissions` table:
```{r}
cohort_admissions %>%
  left_join(cohort_subjects, by = "subject_id", copy = TRUE) %>%
  print() -> cohort_admissions

# collect(cohort_admissions)
```

Now we save the `cohort_admissions` into a csv file for data visualization and analysis:
```{r}
final_cohort <- collect(cohort_admissions)
```

## Close the connection to a database

Close the connection:
```{r}
dbDisconnect(con)
```

## Data Visualization


## Analysis 

### 1. Logistics Regression 

### 2. Neural Network 

## Conclusion 